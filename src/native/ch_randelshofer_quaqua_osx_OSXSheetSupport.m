#import "ch_randelshofer_quaqua_osx_OSXSheetSupport.h"
#import <Cocoa/Cocoa.h>
// #import <JavaNativeFoundation/JavaNativeFoundation.h> // not supported in Tiger
#import <JavaVM/jawt_md.h>

#pragma mark Header part
// This part would normally go in a header, but the standard header for this file is automatically generated.
NSWindow * GetWindowFromComponent(jobject parent, JNIEnv *env);
jint GetJNIEnv(JNIEnv **env, bool *mustDetach);
NSString * GetNSStringFromJString(jstring string, JNIEnv *env);
jstring GetJStringFromNSString(NSString *string, JNIEnv *env);
NSArray * GetNSArrayFromJStringArray(jobjectArray array, JNIEnv *env);

@interface AlertDelegate : NSObject
{
    jint identifier;
    NSAlert *alert;
}

+ (id)alertDelegateWithMessageText:(NSString *)messageTitle withOptions:(NSArray *)options informativeTextWithFormat:(NSString *)informativeText withID:(jint)ident;
- (id) initWithMessageText:(NSString *)messageTitle withOptions:(NSArray *)options informativeTextWithFormat:(NSString *)informativeText withID:(jint)ident;
- (void) runPanel:(NSWindow *)parent;
- (void) alertDidEnd:(NSAlert *)alert returnCode:(int)returnCode contextInfo:(void *)contextInfo;
- (void) setSelectionValues:(NSArray *)selectionValues withDefaultValue:(NSString *)defaultValue;

@end


#pragma mark Implementation part
static JavaVM *jvm;
static jclass sheetSupportClass = nil;
// Callback support removed - not needed
static jmethodID performListenerForIDMethodID = nil;
static jclass osxSheetSupportClass = nil;

/*
 Called when the lib is loaded.
*/
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
	jvm = vm;
	return JNI_VERSION_1_4;
}

/*
 * Return the code version for this native source. It is needed to check the support of a specific JNI library.
 * Class and method IDs are initialized here; we can be sure that this method is called.
 * Class:     ch_randelshofer_quaqua_osx_OSXSheetSupport
 * Method:    nativeGetNativeCodeVersion
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_ch_randelshofer_quaqua_osx_OSXSheetSupport_nativeGetNativeCodeVersion (JNIEnv *env, jclass clazz) {
    sheetSupportClass = clazz;
    
    osxSheetSupportClass = (*env)->NewGlobalRef(env, clazz);
    performListenerForIDMethodID = (*env)->GetStaticMethodID(env, clazz, "performListenerForID", "(IILjava/lang/String;)V");
    
    return 0;
}

/*
 * Class:     ch_randelshofer_quaqua_osx_OSXSheetSupport
 * Method:    nativeShowOptionSheet
 * Signature: (Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Z[Ljava/lang/String;Ljava/lang/String;Ljava/awt/Component;I)V
 */
JNIEXPORT void JNICALL Java_ch_randelshofer_quaqua_osx_OSXSheetSupport_nativeShowOptionSheet (JNIEnv * env, jclass clazz, jstring message, jobjectArray options, jstring format, jboolean wantsInput, jobjectArray selectionValues, jstring initialSelectionValue, jobject component, jint ident) {
    
    NSAutoreleasePool *pool = [NSAutoreleasePool new];
    
    NSWindow *window = GetWindowFromComponent(component, env);
    AlertDelegate *delegate = [[AlertDelegate alloc] initWithMessageText:GetNSStringFromJString(message, env)
                                                             withOptions:GetNSArrayFromJStringArray(options, env)
                                               informativeTextWithFormat:GetNSStringFromJString(format, env)
                                                                  withID:ident];
    if (wantsInput)
        [delegate setSelectionValues:GetNSArrayFromJStringArray(selectionValues, env)
                    withDefaultValue:GetNSStringFromJString(initialSelectionValue, env)];
    [delegate performSelectorOnMainThread:@selector(runPanel:) withObject:window waitUntilDone:NO];
    //[delegate retain];
    
    [pool release];
}

@implementation AlertDelegate

+ (id)alertDelegateWithMessageText:(NSString *)messageTitle withOptions:(NSArray *)options informativeTextWithFormat:(NSString *)informativeText withID:(jint)ident {
    return [[[AlertDelegate alloc] initWithMessageText:messageTitle
                                           withOptions:options
                             informativeTextWithFormat:informativeText
                                                withID:ident]
            autorelease];
}

- (id)initWithMessageText:(NSString *)messageTitle withOptions:(NSArray *)options informativeTextWithFormat:(NSString *)informativeText withID:(jint)ident {
    [super init];
    
    if (informativeText == nil)
        informativeText = @"";
    
    alert = [[NSAlert alloc] init];
    [alert setMessageText:messageTitle];
    [alert setInformativeText:informativeText];
    int i;
    int count = [options count];
    for (i = 0; i < count; i++) {
        NSString *string = [options objectAtIndex:i];
        [alert addButtonWithTitle:string];
    }
    [alert setIcon:[NSApp applicationIconImage]];
    identifier = ident;
    
    return self;
}

- (void)runPanel:(NSWindow *)parent {
    [alert beginSheetModalForWindow:parent
                      modalDelegate:self
                     didEndSelector:@selector(alertDidEnd:returnCode:contextInfo:)
                        contextInfo:nil];
    [[[alert accessoryView] window] makeFirstResponder:[alert accessoryView]];
}

- (void) alertDidEnd:(NSAlert *)a returnCode:(int)returnCode contextInfo:(void *)contextInfo {
    NSView *view = (NSView *)[a accessoryView];
    NSString *result;
    if (view) {
        if ([view isKindOfClass:[NSTextField class]])
            result = [(NSTextField *)view stringValue];
        else
            result = [(NSPopUpButton *)view titleOfSelectedItem];
    } else {
        result = nil;
    }
    
	JNIEnv *env = NULL;
	bool shouldDetach = false;
    
	// Find out if we actually need to attach the current thread to obtain a JNIEnv, 
	// or if one is already in place
	// This will determine whether DetachCurrentThread should be called later
	if (GetJNIEnv(&env, &shouldDetach) != JNI_OK) {
		NSLog(@"alertDidEnd: could not attach to JVM! Aborting.");
		return;
	}
    
    jstring jresult;
    if (result && [result length] > 0)
        jresult = GetJStringFromNSString(result, env);
    else
        jresult = NULL;
    
    // Tell Java to notify the SheetListener
    if (performListenerForIDMethodID != NULL) {
        (*env)->CallStaticVoidMethod(env, osxSheetSupportClass, performListenerForIDMethodID, (jint)identifier, returnCode, jresult);
    } else NSLog(@"performListenerForIDMethodID: bad mID");
    
	// IMPORTANT: if GetJNIEnv attached for us, we need to detach when done
	if (shouldDetach) {
		(*jvm)->DetachCurrentThread(jvm);
	}
    
    // Forget me
    [self release];
}

- (void) setSelectionValues:(NSArray *)selectionValues withDefaultValue:(NSString *)defaultValue {
    if (!selectionValues) {
        NSTextField *textField = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, 200, 22)];
        if (defaultValue)
            [textField setStringValue:defaultValue];
        [alert setAccessoryView:textField];
        [textField release];
    } else {
        NSPopUpButton *comboBox = [[NSPopUpButton alloc] initWithFrame:NSMakeRect(0, 0, 200, 26)];
        [comboBox addItemsWithTitles:selectionValues];
        if (defaultValue)
            [comboBox selectItemWithTitle:defaultValue];
        [alert setAccessoryView:comboBox];
        [comboBox release];
    }
}

- (void)dealloc {
    [alert release];
    alert = nil;
    
    [super dealloc];
}

@end

#pragma mark Embedding headers

@interface AWTView : NSView
{
}

@end

@interface AWTWindow : NSWindow
{
}

@end

#pragma mark Embedding implementation
@implementation AWTView

- (BOOL)acceptsFirstResponder
{
    return YES;
}

- (void) dealloc
{
    NSLog(@"Dealloc of window!");
    [super dealloc];
}

@end

@implementation AWTWindow

- (BOOL)canBecomeKeyWindow
{
    return YES;
}

- (BOOL)canBecomeMainWindow
{
    return YES;
}

- (void) dealloc
{
    NSLog(@"Dealloc of window!");
    [super dealloc];
}


@end

/*
 * Class:     ch_randelshofer_quaqua_osx_OSXSheetSupport
 * Method:    createNativeView
 * Signature: (II)J
 */
JNIEXPORT jlong JNICALL Java_ch_randelshofer_quaqua_osx_OSXSheetSupport_createNativeView(JNIEnv *env, jclass clazz, jint width, jint height)
{
    AWTWindow *window = [[AWTWindow alloc] initWithContentRect:NSMakeRect(0, 0, width, height) styleMask:NSTitledWindowMask backing:NSBackingStoreBuffered defer:YES];
    
    AWTView *view = [[AWTView alloc] initWithFrame:NSMakeRect(0, 0, width, height)];
    [window setContentView:view];
    [window setInitialFirstResponder:view];
    
    return (jlong)view;
}

/*
 * Class:     ch_randelshofer_quaqua_osx_OSXSheetSupport
 * Method:    nativeHideSheet
 * Signature: (J)V
 */
JNIEXPORT void JNICALL Java_ch_randelshofer_quaqua_osx_OSXSheetSupport_nativeHideSheet(JNIEnv *env, jclass clazz, jlong view)
{
    NSView *nsView = (NSView *)view;
    NSWindow *sheetWindow = [nsView window];
    
    [NSApp endSheet:sheetWindow];
    [sheetWindow close];
    [nsView release];
}

/*
 * Class:     ch_randelshofer_quaqua_osx_OSXSheetSupport
 * Method:    nativeSetBounds
 * Signature: (JII)V
 */
JNIEXPORT void JNICALL Java_ch_randelshofer_quaqua_osx_OSXSheetSupport_nativeSetBounds(JNIEnv *env, jclass clazz, jlong view, jint width, jint height)
{
    AWTView *nsView = (AWTView *)view;
    NSWindow *sheetWindow = [nsView window];
    NSRect r = [sheetWindow frame];
    r.origin.x = r.origin.x + r.size.width / 2 - width / 2;
    r.origin.y = r.origin.y + r.size.height - height;
    r.size.width = width;
    r.size.height = height;
    [sheetWindow setFrame:r display:NO animate:NO];
}

/*
 * Class:     ch_randelshofer_quaqua_osx_OSXSheetSupport
 * Method:    showSheet
 * Signature: (Ljava/awt/Window;J)V
 */
JNIEXPORT void JNICALL Java_ch_randelshofer_quaqua_osx_OSXSheetSupport_showSheet(JNIEnv *env, jclass clazz, jobject owner, jlong view)
{
    AWTView *nsView = (AWTView *)view;
    NSLog(@"%i and %@", owner != NULL, nsView);
    NSWindow *ownerWindow = GetWindowFromComponent(owner, env);
    NSWindow *sheetWindow = [nsView window];
    
    NSInvocation *invoc = [NSInvocation invocationWithMethodSignature:[NSApp methodSignatureForSelector:@selector(beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:)]];
    [invoc setSelector:@selector(beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:)];
    [invoc setTarget:NSApp];
    [invoc setArgument:&sheetWindow atIndex:2];
    [invoc setArgument:&ownerWindow atIndex:3];
    [invoc performSelectorOnMainThread:@selector(invoke) withObject:nil waitUntilDone:NO];
    
    NSView *awtView = [[nsView subviews] objectAtIndex:0];
    [sheetWindow makeKeyWindow];
    [sheetWindow makeFirstResponder:awtView];
}


#pragma mark Helper methods

/*
 Determines whether the current thread is already attached to the VM,
 and tells the caller if it needs to later DetachCurrentThread 

 CALL THIS ONCE WITHIN A FUNCTION SCOPE and use a local boolean
 for mustDetach; if you do not, the first call might attach, setting 
 mustDetach to true, but the second will misleadingly set mustDetach 
 to false, leaving a dangling JNIEnv
*/
jint GetJNIEnv(JNIEnv **env, bool *mustDetach) {
	jint getEnvErr = JNI_OK;
	*mustDetach = false;
	if (jvm) {
		getEnvErr = (*jvm)->GetEnv(jvm, (void **)env, JNI_VERSION_1_4);
		if (getEnvErr == JNI_EDETACHED) {
			getEnvErr = (*jvm)->AttachCurrentThread(jvm, (void **)env, NULL);
			if (getEnvErr == JNI_OK) {
				*mustDetach = true;
			}
		}
	}
	return getEnvErr;
}

// Given a Java component, return a NSWindow*
NSWindow * GetWindowFromComponent(jobject parent, JNIEnv *env) {
	JAWT awt;
	JAWT_DrawingSurface* ds;
	JAWT_DrawingSurfaceInfo* dsi;
	JAWT_MacOSXDrawingSurfaceInfo* dsi_mac;
	jboolean result;
	jint lock;
    
	// Get the AWT
	awt.version = JAWT_VERSION_1_4;
	result = JAWT_GetAWT(env, &awt);
	assert(result != JNI_FALSE);
    
	// Get the drawing surface
	ds = awt.GetDrawingSurface(env, parent);
	assert(ds != NULL);
    
	// Lock the drawing surface
	lock = ds->Lock(ds);
	assert((lock & JAWT_LOCK_ERROR) == 0);
    
	// Get the drawing surface info
	dsi = ds->GetDrawingSurfaceInfo(ds);
    
	// Get the platform-specific drawing info
	dsi_mac = (JAWT_MacOSXDrawingSurfaceInfo*)dsi->platformInfo;
    
	// Get the NSView corresponding to the component that was passed
	NSView *view = dsi_mac->cocoaViewRef;
	
	// Free the drawing surface info
	ds->FreeDrawingSurfaceInfo(dsi);
	// Unlock the drawing surface
	ds->Unlock(ds);
    
	// Free the drawing surface
	awt.FreeDrawingSurface(ds);
	
	// Get the view's parent window; this is what we need to show a sheet
	return [view window];
}

// Get a jstring, return a NSString
NSString * GetNSStringFromJString(jstring string, JNIEnv *env) {
    if (string == NULL)
        return nil;
    
    const jchar *chars = (*env)->GetStringChars(env, string, NULL);
    NSString *myNSString = [NSString stringWithCharacters:(UniChar *)chars
                                                   length:(*env)->GetStringLength(env, string)];
    (*env)->ReleaseStringChars(env, string, chars);
    return myNSString;
}

jstring GetJStringFromNSString(NSString *string, JNIEnv *env) {
    // Note that length returns the number of UTF-16 characters,
    // which is not necessarily the number of printed/composed characters
    jsize buflength = [string length];
    unichar buffer[buflength];
    [string getCharacters:buffer];
    jstring javaStr = (*env)->NewString(env, (jchar *)buffer, buflength);
    return javaStr;
}

NSArray * GetNSArrayFromJStringArray(jobjectArray array, JNIEnv *env) {
    if (array == NULL)
        return nil;
    
    jsize length = (*env)->GetArrayLength(env, array);
    NSMutableArray *nsArray = [NSMutableArray arrayWithCapacity:length];
    int i;
    for (i = 0; i < length; i++) {
        jstring string = (*env)->GetObjectArrayElement(env, array, i);
        [nsArray addObject:GetNSStringFromJString(string, env)];
    }
    return nsArray;
}